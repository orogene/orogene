# Managing `node_modules/`

The whole point of Orogene is to manage `node_modules/` directories for
consumption by various tooling, such as Node.js, transpilers, bundlers,
linters, etc.

The process of managing `node_modules/` and making sure all the appropriate
dependencies are in place is called "apply" in orogene. Application happens
through a number of commands, automatically. For example, `oro reapply`, `oro
add`, `oro remove`, and `oro run` all make sure to apply your dependencies as
needed, to make sure your `node_modules/` corresponds to your manifest and
lockfile as much as possible. You can [disable this behavior](#no-apply), as
desired.

## Application blow-by-blow

By default, the `apply` operation will do the following things:

1. Read dependencies declared in `package.json`.
2. Generate a dependency tree based on those.
   1. If a lockfile (`package-lock.kdl` or `package-lock.json`) already
      exists, it will be used to **supplement** the resolution.
   2. If any dependencies in the lockfile are missing or don't correspond to
      expected dependencies, the tree will ignore that particular lockfile
      data and resolve the item(s) itself.
3. Scan through the existing `node_modules/`, if any, and prune anything
   "extraneous" (aka, removed/outdated dependencies, stray files, etc).
4. Extract any missing packages into `node_modules`, into one of two modes:
   1. isolated (default, preferred)
   2. hoisted (possibly more compatible, discouraged because it exposes
      [phantom dependencies](#phantom-dependencies))
5. Execute any `preinstall` scripts on the entire tree, including the root
   package.
6. Link/shim any bins in the dependencies to their appropriate
   `node_modules/.bin` directories.
7. Execute `install` and `postinstall` scripts on the entire tree, including
   the root package.
8. Finally, the updated lockfile is written to `package-lock.kdl`.

### Modifying Application

All commands that execute implicit apply accept the same options for modifying
its behavior. To see the full list, refer to the [apply command
options](../commands/apply.md#apply-options), which are also listed in the
`-h`/`--help` for any command that performs implicit apply.

Some options of note:

#### `--no-apply`

Skips the entire apply operation. This option will have no effect on the `oro
apply` command, which forces an apply regardless of your settings.

This option can be useful if you don't like implicit applies and would like to
generally configure Orogene to skip them by default, but let you use `--apply`
when you happen to want to apply something. To do this, add `apply false` to
your [`oro.kdl` options node](./configuration.md#options-from-orokdl).

#### `--locked`

Instead of using lockfiles as a suggestion/optimization, this option will
force an error if the dependencies declared in `package.json` don't correspond
to the ones declared in an existing `package-lock.kdl`.

This option has no effect in `oro add`/`oro remove`, for hopefully obvious reasons.

#### `--lockfile-only`

Resolves the dependency tree and writes the lockfile as appropriate, but skips
anything having to do with `node_modules` itself, including pruning and
scripts.

#### `--no-lockfile`

Skips writing, or updating the lockfile entirely. As of right now, this will
still **read** the lockfile to inform resolution.

## Phantom Dependencies

"Phantom dependencies" refers to a phenomenon where dependencies that weren't
directly declared in a package's `package.json` can be imported from those
packages. It arises primarily from "hoisted" `node_modules` trees where, in
order to reduce duplication, shared dependencies are moved as high up the tree
as possible, exposing them to everyone _else_ at that level or deeper.

By default, Orogene uses an "isolated" linking strategy to avoid this: All
dependencies are first written to
`<root>/node_modules/.oro-store/<dep>-12345/node_modules/<dep>`, then every
dependency inside the store, along with the root package,  gets their own
individual `node_modules` that contains symlinks _back into the store_, only
for dependencies directly declared in their `package.json`. This avoids the
phantom dependencies problems and ensures that you don't accidentally forget
to add a dependency to your `package.json` just because of the state of your
dependency tree at any given point in time.

The catch with this isolated mode is that most NPM packages in the public
registry have been written in a world where the NPM CLI defaults to "hoisted"
installations, so a number of packages out in the wild depend on this
behavior, purely by accident. The best fix for this is simply to patch the
offending package and install an updated version.

When this is not possible, you can use `--hoisted` to force Orogene to apply
dependencies in a classic, flattened-as-much-as-possible style. As with other
options, this can be added to your `oro.kdl` as needed.
